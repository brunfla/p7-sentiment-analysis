import os
from flask import Flask, request, jsonify
from clean_tweet import clean_tweet
from advanced_clean_glove import clean_with_glove
from tokenize_tweet import tokenize_tweet
from model_utils import load_model, predict_sentiment
import pickle  # Ajouté pour charger les vecteurs GloVe

# Initialiser l'application Flask
app = Flask(__name__)

# Charger les configurations depuis les variables d'environnement
MODEL_PATH = os.getenv("MODEL_PATH", "data/output/distilbert_model.keras")
GLOVE_PATH = os.getenv("GLOVE_PATH", "data/output/glove_vectors.pkl")
HOST = os.getenv("FLASK_HOST", "0.0.0.0")
PORT = int(os.getenv("FLASK_PORT", 5000))

# Charger le modèle et les ressources au démarrage
model = load_model(MODEL_PATH)

# Charger les vecteurs GloVe en mémoire une fois
with open(GLOVE_PATH, 'rb') as f:
    glove_vectors = pickle.load(f)  # Exemple de chargement des vecteurs depuis un fichier pickle

@app.route('/predict', methods=['POST'])
def predict():
    """
    Endpoint pour prédire le sentiment d'un tweet.
    Expects:
    - JSON: { "tweet": "texte du tweet" }
    Returns:
    - JSON: { "sentiment": "positif" ou "négatif" }
    """
    try:
        data = request.get_json()
        tweet = data.get("tweet", "")

        if not tweet:
            return jsonify({"error": "Tweet non fourni"}), 400

        # Étapes de prétraitement
        cleaned_tweet = clean_tweet(tweet)
        cleaned_tweet = clean_with_glove(cleaned_tweet, glove_vectors)  # Utilise la variable globale
        tokenized_tweet = tokenize_tweet(cleaned_tweet)

        # Prédiction
        sentiment = predict_sentiment(model, tokenized_tweet)

        return jsonify({"tweet": tweet, "sentiment": sentiment})

    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(host=HOST, port=PORT)


